# Liberty for Java microservices showcase repository

## Overview

This repository contains simple, sample project that shows how to build and deploy microservice application using Java and WebSphere Liberty.

Complexity Calculator Service is an application that calculates complexity of the applications that are to be migrated to WebSphere based on JSON inventory report produced by the [Migration Toolkit for Application Binaries](https://developer.ibm.com/wasdev/docs/migration-toolkit-application-binaries-tech/).

It takes as input JSON data as POSTed string or as submited file and returns JSON object of the following format:

```
{
	"simpleWars":0,
	"appClients":0,
	"moderateWars":3,
	"moderateEJBs":5,
	"rars":1,
	"complexWars":0,
	"complexEJBs":1
}
```

## Design decisions

### Project setup
To speed up setup of the project, the stub was generated by the [Liberty app accelerator](http://liberty-app-accelerator.wasdev.developer.ibm.com/start/api/), which creates correct Maven project structure, includes repository for WebSphere Liberty and also generates configuration with specified features for WebSphere Liberty server. 


### Creating Java classes from json file
Classes were created from json file using json to Java transformation. I've used the following page to do the transformation: http://www.jsonschema2pojo.org/. This URL is a web based tool that will create a JSON schema from JSON data.
As source json contains same object on multiple levels for example archives and summary:

```
{
    ...
   "archives": {
    ...
   },
   "summary": {
   ....
   },
   "archiveInventory": [
      {
         ....
         "archives": {
		   ....
         },
         "summary": {
          ...
         },
         ...
     }
   ]
   ....
}
```

that page generated several same classes, like Archives.java, Archives_.java, Archives___.java. For simplicity, the redundant files were removed, and class model was fixed.

It would be nicer, if we had a json schema file for the inventory report, since this would ensure that we have all the properties mapped. Example of json schema file can be seen here - http://json-schema.org/examples.html. 
I've tried several reports to find most of the properties from the report, but since the properties are optionally generated, there is no guarantee that class model contains all the properties that can show up in reports.

### HTTP methods usage
There are many pages describing which methods should be used in general for RESTful services e.g. http://www.restapitutorial.com/lessons/httpmethods.html
The general guidance can be summarized in the following table, later there is brief discussion about methods used in the application.


HTTP Verb | CRUD | Comments
--------- | ---- | ---------
POST | Create | POST is commonly used to create resource. It is recommended for non-idempotent resource requests. Making two identical POST requests will most-likely result in creation of two separate resources containing the same information, but it depends on actual application implementation.
GET | Read | GET is used to read data related to the resource. It should be idempotent - several identical requests should return same data, without any side effects on the server side.
PUT | Update/Replace | PUT is commonly used to update resource (however sometimes it might be also used to create, although this is not recommended). Because it modifies resource it is not safe operation, however it should be implemented as idempotent - multiple updates should result in the same state of the resource (not like for example implementing counter, where each update results in different state of the resource). 
PATCH | Update/Modify | PATCH modifies the resource, but it may only contain data needed for modification not the whole resource like PUT. It is assumed not to be idempotent.
DELETE | Delete | DELETE should be used to remove a resource identified by a URI. Implementation should not contain any side effects, so repeated DELETE requests to the same resource should either return same result, or 404 informing that resource is already gone.

In case of the Complexity Calculator Service there was no straight forward choice. 
The POST method is the most common method used to send files via http forms, and is widely supported. To be consistent, the other method which takes JSON as input, is also using POST, as these methods differs only in the form of input data, not functionality. Also some well known services (e.g. [Google Tanslante](https://cloud.google.com/translate/docs/translating-text) ] is also using POST, when input is a JSON data.

Use GET method would also be possible, however not practical in this case. The input data can be very long and complex, which would make URL unreadable, if put as query string parameter; and putting any data as GET request body is not recommentded, and considered a bad practice - http://stackoverflow.com/questions/978061/http-get-with-request-body




